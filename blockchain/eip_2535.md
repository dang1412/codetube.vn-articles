# Solidity contract upgradable EIP-2535

Về cơ bản smartcontract trên ETH hay các hệ tương thích EVM (Etherium Virtual Machine) như BSC hay Avax có tính chất immutable tức là code khi đã được deploy lên 1 địa chỉ cố định thì không thể thay đổi. Điều này giúp tăng tính minh bạch và việc audit hoạt động của smartcontract thuận tiện hơn cho người dùng. Tuy nhiên lại có 1 điểm bất lợi rõ ràng là gây khó khăn trong việc sửa lỗi hay thêm tính năng mới cho smartcontract, mà đây lại là những thao tác rất quan trọng và diễn ra liên tục trong qui trình phát triển phần mềm.

Trong 1 số trường hợp chúng ta có thể update contract bằng cách sửa code và deploy lên 1 địa chỉ contract mới, sau đó migrate toàn bộ data cần thiết từ contract cũ sang contract mới và update địa chỉ contract phía ứng dụng frontend. Thông thường data trong contract cũ là do transaction của người dùng tạo ra và do người dùng trả phí vậy nên để migrate toàn bộ data người dùng sang địa chỉ contract mới có thể tốn chi phí rất lớn.

Một số trường hợp khác ví dụ như contract hold fund của người dùng và nhà phát triển không thể tự ý chuyển đi, khi xảy ra lỗi gần như nhà phát triển không thể làm gì. Đây là điểm khó khăn cơ bản của 1 ứng dụng phi tập trung.

## Proxy

Solidity cung cấp tính năng `delegatecall` cho phép từ contract A gọi đến hàm `public/external` trong contract B nhưng chạy trong context của contract A (hay nói cách khác là chạy hàm của B nhưng truy cập đến data của contract A).

```sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

// NOTE: Deploy this contract first
contract B {
    // NOTE: storage layout must be the same as contract A
    uint public num;
    address public sender;
    uint public value;

    function setVars(uint _num) public payable {
        num = _num;
        sender = msg.sender;
        value = msg.value;
    }
}

contract A {
    uint public num;
    address public sender;
    uint public value;

    function setVars(address _contract, uint _num) public payable {
        // A's storage is set, B is not modified.
        (bool success, bytes memory data) = _contract.delegatecall(
            abi.encodeWithSignature("setVars(uint256)", _num)
        );
    }
}
```

Tính năng này cho phép chúng ta thiết kế contract có khả năng update bằng cách:

- Deploy 1 contract chứa logic ứng dụng như bình thường.
- Tạo 1 contract gọi là proxy chứa địa chỉ của contract đã deploy ở trên, tất cả các gọi hàm từ bên ngoài được chuyển tiếp đến contract logic dùng `delegatecall`.

Người dùng tương tác với contract proxy, tất cả dữ liệu đọc ghi sẽ được thực hiện trong context của contract proxy (sử dụng storage của proxy). Như vậy ta có thể update contract bằng cách:

- Deploy contract logic đã update sang 1 địa chỉ mới.
- Update biến chứa địa chỉ contract logic trong proxy.

Như vậy khi người dùng tương tác với proxy như bình thường thực chất là đang gọi đến logic mới đã được update, và data tương tác vẫn là data trong proxy như cũ. Ở đây có điểm cần lưu ý, vì mỗi contract đều có state variable (data) của riêng mình nhưng thực chất sử dụng chung 1 storage layout (của contract proxy) nên khi khai báo data ở 2 contract cần phải tương thích với nhau. Ví dụ trong proxy contract chúng ta sử dụng biến chứa địa chỉ contract logic, và trong logic contract sử dụng biến `uint256 x` ta khai báo như sau:

```sol
contract Proxy {
  address public implementation;  // slot 0
}

contract LogicV1 {
  address public implementation;  // slot 0
  uint256 public x;               // slot 1
}
```

Ta thấy trong logic contract không sử dụng biến `implementation` nhưng nếu không khai báo biến x sẽ ghi đè lên vị trí của `implementation` (trong storage layout của proxy). Tham khảo [upgradeable-proxy](https://solidity-by-example.org/app/upgradeable-proxy/). Đồng thời các bạn tham khảo thêm [StorageLayout](https://docs.soliditylang.org/en/v0.8.10/internals/layout_in_storage.html) để hiểu thêm cách smartcontract ghi state variable theo từng slot.

Thông thường các biến storage trong smartcontract được ghi lần lượt theo thứ tự được khai báo ở các vị trí slot 0,1,2... mỗi slot 32 bytes. Tuy nhiên solidity cho phép thay thế vị trí slot mặc định bằng cách gán cho biến storage 1 vị trí slot bất kỳ. Áp dụng cách này vào proxy ở trên ta có thể tách biệt biến storage của smartcontract proxy và biến storage của smartcontract logic ở 2 vị trí riêng để không bị ghi đè lên nhau:

- Biến storage của smartcontract proxy được set ở 1 ví trị ngẫu nhiên cố định.
- Biến storage của smartcontract logic giữ nguyên layout mặc định.

Đưa biến cần dùng vào trong 1 `struct` để có thể quản lý nhiều biến cùng lúc, ta có thể cài đặt như sau

```js
contract Proxy {
  bytes32 constant PROXY_STORAGE_POSITION = keccak256("proxy.standard.storage");

  struct ProxyStorage {
    address public implementation;
    // uint256 var2;
    // uint256 var3;
  }

  function proxyStorage() internal pure returns (ProxyStorage storage ps) {
    assembly {
      ps.slot := PROXY_STORAGE_POSITION
    }
  }

  function updateImplAddr(address _impl) external {
    // lấy ra biến storage trỏ vào vị trí đã định
    ProxyStorage storage ps = proxyStorage();
    // ghi đè vào storage
    ps.implementation = _impl;
  }

  function doSomething() external {
    // lấy ra biến storage trỏ vào vị trí đã định
    ProxyStorage storage ps = proxyStorage();
    // ...delegate call cho address 'ps.implementation'
  }
}
```

Sau đó trong smartcontract logic ta có thể khai báo và sử dụng biến storage như bình thường mà không cần bận tâm đến biến storage của proxy (đã được set ở 1 vị trí riêng)

```sol
contract LogicV1 {
  uint256 public x; // slot 0
  uint256 public y; // slot 1
}

contract LogicV2 {
  uint256 public x; // slot 0
  uint256 public y; // slot 1
  address public z; // slot 2
}
```

Chú ý là ở các version update mới của contract logic storage layout phải tương thích với version cũ để không bị conflict storage slot.

## EIP-2535

Chuẩn [EIP-2535](https://eips.ethereum.org/EIPS/eip-2535) được đề xuât bởi [Nick Mudgen]() là 1 thiết kế nâng cấp so với cách cài đặt `proxy` ở trên

<!-- - Có nhiều hơn 1 contract logic, mỗi contract logic gọi là 1 mặt cắt kim cương (Diamond facet). -->
- Contract proxy gọi là kim cương (Diamond), bao gồm nhiều contract logic gọi là mặt cắt (Facet).
- Diamond lưu giữ data chứa thông tin các facet, mỗi `function` được map đến 1 facet cụ thể. Data này được khai báo là 1 `struct` lưu trữ ở 1 slot ngẫu nhiên cố định.
- Tất cả các facet dùng chung 1 `struct` chứa tất cả các biến dùng trong các facet, sử dụng slot mặc định 0. Ngoài ra facet không khai báo thêm biến riêng nào khác.
- Diamond chứa 2 facet khởi tạo
  - `DiamondCutFacet`: sử dụng để update Diamond cho phép thêm bớt hoặc thay thế các facet và các `function` hiện tại, có thể loại bỏ chính nó để biến thành `immutable contract`.
  - `DiamondLoupeFacet`: dùng để quan sát Diamond, liệt kê thông tin các facet, các `function` bao gồm trong facet.

Thiết kế này cho chúng ta những ưu điểm

- Contract upgradable.
- Logic phức tạp có thể được chia thành các module nhỏ dễ quản lý.
- Không bị hạn chế bởi tính chất mỗi contract không được quá 24kb bytecode.
- Data của smartcontract được qui về 1 chỗ dễ quản lý.

Tuy nhiên để vận dụng thành thục phương pháp này từ deploy, khởi tạo đến upgrade cũng khá phức tạp, chúng ta cùng đi vào triển khai 1 Diamond cụ thể.

## Triển khai EIP-2535

Cài đặt ở đây dựa trên sample [Diamond-1](https://github.com/mudgen/diamond-1-hardhat) của tác giả nhưng sử dụng `Typescript` và mình sẽ thêm vào kỹ hơn ở các bước

- Cài đặt
- Deploy Diamond, Facet.
- Khởi tạo cho Facet.
- Update Facet.
